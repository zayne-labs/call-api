---
title: Hooks / Interceptors
description: Learn how to use request and response interceptors
---

Hooks / Interceptors are callback functions that are called at different stages of the request lifecycle. Each hook receives a specific context object and can be async.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const callApi = createFetchClient({
	baseURL: "http://localhost:3000",
	onRequest: (context) => {},
	onRequestError: (context) => {},
	onResponse: (context) => {},
	onResponseError: (context) => {},
	onError: (context) => {},
	onSuccess: (context) => {},
	onRetry: (context) => {},
});

callApi("/api/data", {
	onRequest: (context) => {},
	onRequestError: (context) => {},
	onResponse: (context) => {},
	onResponseError: (context) => {},
	onError: (context) => {},
	onSuccess: (context) => {},
	onRetry: (context) => {},
});
```

## Request Phase Hooks

### onRequest

This hook is called before a request is sent. You can use this to modify request configuration, add headers, or handle authentication.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const client = createFetchClient({
	onRequest: ({ request, options }) => {
		// Add auth header
		options.auth = localStorage.getItem("token");

		// Add custom headers
		request.headers && (request.headers["X-Custom-ID"] = "123");

		// Modify URL or query params
		if (options.fullURL?.includes("api.dev")) {
			request.headers && (request.headers["X-Environment"] = "development");
		}
	},
});
```

### onRequestError

This hook is called when the request fails before reaching the server. You can use it to handle network errors, timeouts, etc.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const client = createFetchClient({
	onRequestError: ({ error, request, options }) => {
		if (error.name === "TimeoutError") {
			console.error(`Request timeout: ${options.initURL}`);
			return;
		}

		console.error(`Network error: ${error.message}`);
	},
});
```

## Response Phase Hooks

### onResponse

This hook is called for every response from the server, regardless of the status code. You can use it to log all API calls, handle specific status codes, etc.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const client = createFetchClient({
	onResponse: ({ data, error, request, response, options }) => {
		// Log all API calls
		console.log(`${request.method} ${options.initURL} - ${response.status}`);

		// Handle specific status codes
		if (response.status === 207) {
			console.warn("Partial success:", data);
		}
	},
});
```

### onSuccess

This hook is called only for successful responses. You can use it to handle successful responses, cache data, etc.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

type User = {
	id: string;
	name: string;
	email: string;
};

const userCache = new Map<string, User>();

const client = createFetchClient<User[]>({
	onSuccess: ({ data, response, request, options }) => {
		// Cache user data
		data.forEach((user) => userCache.set(user.id, user));
	},
});
```

### onResponseError

This hook is called for error responses (response.ok === false). You can use it to handle specific status codes, etc.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const client = createFetchClient({
	onResponseError: ({ error, response, options }) => {
		switch (response.status) {
			case 401:
				//Handle Token expired
				break;

			case 403:
				// Handle User not authorized
				break;

			case 404:
				// Handle Resource not found
				break;

			case 429:
				// Handle Rate limited
				break;
		}
	},
});
```

### onError

Called for any error .

This hook is called for any error. It's basically a combination of onRequestError and onResponseError. It's perfect for global error handling.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const client = createFetchClient({
	onError: ({ error, response, request, options }) => {
		// Send to error tracking
		// errorTracker.capture({
		// 	type: error.name,
		// 	message: error.message,
		// 	url: request.url,
		// 	status: response?.status,
		// });

		// Show user-friendly messages
		if (!response) {
			// showNetworkError();
		} else if (response.status >= 500) {
			// showServerError();
		} else if (response.status === 400) {
			// showValidationErrors(error.errorData);
		}
	},
});
```

## Retry Phase Hooks

### onRetry

This hook is called before retrying a failed request. You can use it to handle stuff before retrying.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

const client = createFetchClient({
	// Advanced retry configuration
	retryAttempts: 3,
	retryStrategy: "exponential",
	retryStatusCodes: [408, 429, 500, 502, 503, 504],

	onRetry: ({ response }) => {
		// Handle stuff...
	},
});
```

## Things to Note

Here are some important details about how hooks work:

### Array Support

Any hook can be an array of callbacks that run in sequence:

```ts
const { error } = await callApi("/api/data", {
	onRequest: [
		(ctx) => addAuthHeader(ctx.request),
		(ctx) => addTrackingHeader(ctx.request),
		(ctx) => addVersionHeader(ctx.request),
	],
});
```

### Hook Priority Levels

Hooks can be defined at three levels, executing in the following order:

1. **Plugin Level**: Runs first
2. **Base Client Level**: Runs second
3. **Instance Level**: Runs last and overrides base hooks if base hooks aren't defined as an array

```ts title="example.ts"
import { createFetchClient, definePlugin } from "@zayne-labs/callapi";

// Plugin hooks (run first)
const loggingPlugin = definePlugin({
	name: "logger",
	hooks: {
		onRequest: () => console.log("1. Plugin onRequest"),
	},
});

// Base client hooks (run second)
const client = createFetchClient({
	plugins: [loggingPlugin],
	// Single callback
	onRequest: () => console.log("2. Base onRequest"),
	// Or array of callbacks
	onResponse: [() => console.log("2.1 Base onResponse"), () => console.log("2.2 Base onResponse")],
});

// Request-specific hooks (run last)
await client("/api/data", {
	// Overrides base onRequest
	onRequest: () => console.log("3. Request onRequest"),
	// Merges with base onResponse array
	onResponse: () => console.log("3. Request onResponse"),
});
```

### Override Behavior

There are three ways hooks can behave when overriding:

1. **Regular Hooks**: Instance hooks completely replace base hooks. If you override a hook, the base hook won't run.
2. **Plugin Hooks**: These run first by default and can't be overridden, making them perfect for must-have functionality.
3. **Array Hooks**: When the base hook is an array, instance hooks are **merged** with the corresponding base hook, allowing you to add additional functionality without overriding existing logic. This behavior is purely for convenience if you don't want to make a plugin just to avoid overrides.

Here's how each behaves:

```ts
// 1. Regular hooks - base hook is replaced

const callBackendApi = createFetchClient({
	onRequest: (ctx) => addAuthHeader(ctx.request),
});

const result = callBackendApi("/api", {
	onRequest: (ctx) => addVersionHeader(ctx.request), // Only this runs, auth header is lost!
});

// 2. When the base hook is an Array - corresponding instance hooks are merged instead of overriding the base hook
const callAnotherApi = createFetchClient({
	onRequest: [(ctx) => addAuthHeader(ctx.request)],
});

const anotherResult = callAnotherApi("/api", {
	onRequest: (ctx) => addVersionHeader(ctx.request), // Both hooks run!
});

// 3. Plugin hooks - runs first by default
const authHeaderPlugin = definePlugin({
	id: "auth-header-plugin",
	description: "Add Auth Header",

	hooks: {
		onRequest: (ctx) => addAuthHeader(ctx.request),
	},
});

const clientWithPlugin = createFetchClient({
	plugins: [authHeaderPlugin],

	onRequest: (ctx) => addVersionHeader(ctx.request),
});
```

### Async Support

All hooks can be async - simply return a Promise or use async/await:

```ts
onRequest: async ({ request }) => {
	const token = await getAuthToken();
	request.headers.set("Authorization", `Bearer ${token}`);
},
```

### Type Safety

All hooks are fully typed based on the response type you specify when creating the client. This ensures you get proper type inference and autocompletion for the data and error objects in all your hooks.

```ts twoslash title="example.ts"
import { createFetchClient } from "@zayne-labs/callapi";

type User = {
	id: number;
	name: string;
};

const client = createFetchClient<User>({
	onSuccess: ({ data }) => {
		console.log(data.name);
	},
});

const { error } = await client("/api/data", {
	onSuccess: ({ data }) => {
		console.log(data.name);
	},
});

// @annotate: Hover over the data object to see the inferred type
```
